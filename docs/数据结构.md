# 1 数据结构

## 1.1 数组

### 1.1.1 时间复杂度

数组增删改查的时间复杂度见下表

|          | 末尾   | 中间   |
| -------- | ------ | ------ |
| `add`    | $o(1)$ | $o(N)$ |
| `remove` | $o(1)$ | $o(N)$ |
| `set`    | $o(1)$ | $o(1)$ |
| `get`    | $o(1)$ | $o(1)$ |

> * `add`元素的时候可能会涉及到数组的扩容操作，但是并不是每次增加元素都会出现扩容，所以扩容的复杂度要用均摊时间复杂度来分析。
> * **查**和**改**操作仅仅适用于给定索引的情况，如果要拿着固定的值去寻找对应的索引，时间复杂度为$o(N)$

### 1.1.2 动态数组

> TODO

## 1.2 链表

### 1.2.1 链表的优劣

**① 优点**

* 不需要连续的内存空间存储元素
* 不需要考虑扩容和数据迁移问题，理论上链表的容量是无限的

**② 缺点**

* 不支持随机访问元素

### 1.2.2 单链表的基本操作

**① 遍历元素**

```java
ListNode p = head;
while (p != null) {
    System.out.println(p.val);
    p = p.next;
}
```

**② 增加元素**

```java
// 头插法添加元素
public ListNode addHead(ListNode head, int val) {
    ListNode newNode = new ListNode(val);
    newNode.next = head.next;
    head.next = newNode;
    return head;
}

// 尾插法
public ListNode addTail(ListNode head, int val) {
    ListNode newNode = new ListNode(val);
    ListNode p = head;
    while (p.next != null) {
        p = p.next;
    }
    p.next = newNode;
    return head;
}

// 在指定位置，第 n 个节点后面添加
public ListNode add(ListNode head, int val, int n) {
    ListNode p = head;
    // 找到前驱节点
    for (int i = 0; i < n - 1; i++) {
        p = p.next;
    }
    ListNode node = new ListNode(val);
    node.next = p.next;
    p.next = node;
    return head;
}
```

**③ 删除元素**

```java
// 删除第 n 个节点
public ListNode add(ListNode head, int val, int n) { 
	ListNode p = head;
    // 找到第 n个节点的前驱节点
    for (int i = 0; i < n - 1; i++) {
        p = p.next;
    }
    // 将前驱节点的后继指针指向当前节点的后继指针
    p.next = p.next.next;
    return head;
}
```

### 1.2.3 双链表的基本操作

略

## 1.3 队列和栈

### 1.3.1 基本概念

* **队列**：先进先出
* **栈**：先进后出

### 1.3.2 使用链表来实现队列和栈

### 1.3.3 环形数组

**环形数组**可以利用求模运算，将普通数组变为逻辑上的环形数组，可以让我们使用$o(1)$的时间在数组头部增删元素。环形数组的关键在于求模运算`%`，当索引`i`到达数组尾部元素时，`i + 1`和`arr.length`取余会变成0，回到数组头部。逻辑上形成了一个环形数组。

```java
i = (i + 1) % arr.length;
```

环形数组的关键在于维护了两个指针`start`和`end`，`start`指向第一个有效元素，而`end`指向最后一个有效元素。

> 区间开闭问题：
>
> 环形数组的区间定义为左闭右开的，即`[start, end)`区间包含数组元素。这样更加有利于处理边界条件。

### 1.3.4 数组实现队列和栈

代码略。

### 1.3.5 双端队列原理和实现

**双端队列**：头部和尾部都可以实现插入或者删除元素。

## 1.4 哈希表

### 1.4.1 基本原理

**1.4.1.1 底层结构**

哈希表是通过**数组**加**链表|红黑树**实现的。

**1.4.1.2 关键概念**

**① 哈希函数**

将输入的`key`转换为固定长度的输出。

**② 哈希冲突**

两个不同的`key`通过哈希函数得到了相同的索引

* 拉链法
* 开放地址法

**③ 扩容与负载因子**

* 扩容容量：元素数量 > 当前容量 * 0.75 则当前容量 变为 2 倍
* 负载因子：0.75

> Map中的Key必须是不可变的

## 1.5 二叉树

> 二叉树值最重要的数据结构，没有之一

### 1.5.1 基本概念

**① 完全二叉树**

每一层节点都**紧凑靠左**排列，除了最后一层，其他层都是**满二叉树**

**② 满二叉树**

每一层节点都是满的

**③ 二叉搜索树**

二叉搜索树（Binary Search Tree, BST），对于每个树的节点，其**左子树**的每个节点的值都要**小于**父节点的值，**右子树**的每个节点的值都要**大于**父节点的值，即**左小右大**

### 1.5.2 二叉树的递归遍历

所谓前序遍历：父节点 -> 左孩子 -> 右孩子

```java
/**
 * 遍历
 * @param root
 * @return
 */
public static final List<Integer> traverse(TreeNode root, Traverse t) {
    List<Integer> resList = new ArrayList<>();
    if (root == null) return null;
    switch (t) {
        case PREFIX: prefixTraverse(root, resList); break;
        case INFIX: infixTraverse(root, resList); break;
        case POSTFIX: postfixTraverse(root, resList); break;
        case LEVEL: levelTraverse(root, resList);
        default: throw new RuntimeException("遍历类型出错");
    }
    return resList;
}

/**
 * 后序遍历
 * @param root
 * @param resList
 */
private static void postfixTraverse(TreeNode root, List<Integer> resList) {
    if (root == null) return;

    postfixTraverse(root.left, resList);

    postfixTraverse(root.right, resList);

    resList.add(root.val);
}

/**
 * 中序遍历
 * @param root
 * @param resList
 */
private static void infixTraverse(TreeNode root, List<Integer> resList) {
    if (root == null) return;

    infixTraverse(root.left, resList);

    resList.add(root.val);

    infixTraverse(root.right, resList);
}

/**
 * 前序遍历
 * @param root
 * @param resList
 */
private static void prefixTraverse(TreeNode root, List<Integer> resList) {
    if (root == null) return;
    resList.add(root.val);
    prefixTraverse(root.left, resList);
    prefixTraverse(root.right, resList);
}


/**
 * 二叉树的层序遍历
 * @param root
 * @param resList
 */
public static void levelTraverse(TreeNode root, List<Integer> resList) {
    if (root == null) return;
    Queue<TreeNode> nodeQueue = new LinkedList<>();
    nodeQueue.add(root);
    while (!nodeQueue.isEmpty()) {
        TreeNode curNode = nodeQueue.poll();
        // 访问当前节点
        resList.add(curNode.val);
        
        // 将当前节点的左右孩子加入队列中
        if (curNode.left != null) {
            nodeQueue.add(curNode.left);
        }
        
        if (curNode.right != null) {
            nodeQueue.add(curNode.right);
        }
    }
}
```

### 1.5.3 多叉树的遍历

> 多叉树结构是二叉树结构的延伸，多叉树遍历是二叉树遍历的延伸。

多叉树的结构：

```java
class TreeNode {
    int val;
    List<TreeNode> children;
}
```

**① 递归遍历**

```java
void traverse (TreeNode root) {
    if (root == null) {
        return;
    }
    
    // 前序遍历
    
    for (int i = 0; i < children.size(); i++) {
        traverse(children[i]);
    }
    
    
    // 后序位置
}
```

**② 层序遍历**

```java
void levelTraverse(TreeNode root) {
    if (root == null) return;
    
    Queue<TreeNode> nodeQueue = new LinkedList<>();
    nodeQueue.add(root);
    int depth = 1;
    while (!nodeQueue.isEmpty) {
        int size = nodeQueue.size();
        for (int i = 0; i < size; i++) {
            TreeNode cur = nodeQueue.poll();
            System.out.println("depth: " + depth + ", val: " + cur.val);
            
            for (TreeNode node : cur.children) {
                nodeQueue.add(node);
            }
        }
        depth++;
    }
}
```

### 1.5.4 实现堆排序

顺序存储二叉树：

* 下标为`i`的左孩子的下标为`2 * i + 1`
* 下标为`i`的右孩子的下标为`2 * i + 2`
* 下标为`i`的父节点的下标为`i / 2 - 1`

 **堆排序原理**

* 从最后一个非叶子节点开始，构建大根堆
* 逐一将最大元素移动到数组末尾
* 调整堆结构

**构建大根堆的方法**

* 分别定位当前节点，左孩子和右孩子
* 找出最大值
* 如果当前节点不是最大值，则和最大值交换
* 递归调整堆

**堆排序实现**

```java
public class Heap {
    public static void sort(int[] arr) {

        if (arr == null || arr.length <= 1) return;
        int n = arr.length;

        // 从最后一个非叶子节点构建大顶堆 n / 2 - 1
        for (int i = n / 2 - 1; i >= 0; i--) {
            // 递归构建大根堆
            heapify(arr, n, i);
        }

        // 逐一将最大的元素移动到数组末尾
        for (int i = n - 1; i >= 0; i--) {
            swap(0, i, arr);

            // 调整堆结构, 堆尾索引为 i， 父节点索引为 0
            heapify(arr, i, 0);
        }

    }

    /**
     * 交换数组两个元素的值
     * @param i
     * @param j
     */
    private static void swap(int i, int j, int[] arr) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * 调整对结构，使其称为最大堆
     * @param arr
     * @param n 结尾索引
     * @param i 当前节点索引
     */
    private static void heapify(int[] arr, int n, int i) {
        int largest = i; // 默认当前索引值是最大的
        int l = 2 * i + 1;
        int r = 2 * i + 2;

        // 如果左孩子更大
        if (l < n && arr[l] > arr[largest]) {
            largest = l;
        }

        // 如果右孩子大
        if (r < n && arr[r] > arr[largest]) {
            largest = r;
        }

        // 如果最大的不是本节点
        if (largest != i) {
            // 交换当前节点和最大的节点
            swap(largest, i, arr);

            // 调整堆结构，从某个孩子开始，调整为最大堆
            heapify(arr, n, largest);
        }

    }
}
```

# 2 算法核心框架

## 2.1 总览

> 关于数据结构和算法的**精炼总结**：
>
> * 所有的数据结构，底层皆为**数组**（顺序存储）和**链表**（链式存储）
> * 数据结构的关键点在于**遍历和访问**，即元素的增删改查等基本操作
> * 所有的算法，本质皆为**穷举**
> * 穷举的关键点在于**无遗漏和无冗余**。熟悉掌握算法框架，可以做到无遗漏；充分利用信息，可以做到无冗余。

### 2.1.1 数据结构的存储方式

如上文所讲，数据结构的存储方式只有两种：**数组**和**链表**

### 2.1.2 数据结构的基本操作

对于任何数据结构，其基本操作为**遍历和访问**，具体来讲就是增删改查

* **线性结构**：使用`for|while`循环
* **非线性结构**：使用**递归**遍历

## 2.2 算法的本质

算法的本质是**穷举**。

穷举的两个关键：

* **无遗漏**：出现遗漏是对算法框架的掌握不到位，不能正确穷举代码
* **无冗余**：没有充分利用有效信息

面对一道算法题，两个维度思考：

* **如何穷举？**无遗漏穷举出所有的可能解
* **如何聪明地穷举**？避免所有的冗余计算，尽可能少地消耗资源求出答案

### 2.2.1 如何穷举？

**递归类问题**、**回溯算法**、**动态规划算法**等算法的解题关键在于如何正确地穷举。

* **回溯算法**的核心在于**遍历**
* **动态规划**核心在于**分解问题**

### 2.2.2 如何聪明地穷举？

**二分搜索算法**、**并查集**、**贪心算法**

## 2.3 数组|链表系列算法

### 2.3.1 单链表

单链表常用的解题技巧为**双指针**，属于**聪明穷举**一类。

常见的链表题目有：[双指针解决链表](#5.1.1 双指针解决链表)

### 2.3.2 数组

常用的解题技巧为**双指针**，属于**聪明穷举**一类。

双指针的技巧主要分为两类：**左右指针**和**快慢指针**。

* **左右指针**：两个指针相向而行或者相背而行
* **快慢指针**：两个指针同向而行，但是一快一慢

#### 2.3.2.1 快慢指针技巧

**1）原地修改**

[T26删除有序数组的重复项](#T26 删除有序数组中的重复项)、[T27 移除元素](#T27 移除元素)、[T283 移动零](#T283 移动零)

**2）滑动窗口**

滑动窗口主要用来解决**子数组的问题**，比如寻找某个条件的最长或者最短的子数组。

滑动窗口本质上就是维护一个可变大小的窗口，不断滑动，更新答案，算法的逻辑如下：

```java
int left = 0, right = 0;

while (right < nums.length) {
    // 增大窗口
    window.addLast(nums[right]);
    right++;
    
    // 缩小窗口
    while (windows needs shrink) {
        window.removeFirst(nums[left]);
        left++;
    }
}
```

基于滑动窗口的算法的时间复杂度为$o(N)$ ，左右双指针不会回退，只会增加，每个元素最多完成一次入窗或者出窗的操作。

> 注意：滑动窗 并不能穷举出所有的子串，滑动窗是利用已有条件，帮助我们聪明地穷举，进行剪枝优化，避免冗余计算。

==*重要*== 以下是一套滑动窗口的代码框架，适用性非常强，只需要按照要求在相关的地方修改即可。

```java
void slidingWindow(String s) {
    /* 使用合适的数据结构记录窗口中的数据，根据场景变通
     * 例如记录元素出现的频次，就用 map
     * 例如记录窗口中出现的元素和，可以使用 int
     */
    Object window = new Object;
    
    int l = 0, right = 0; // 窗口的边界
    while (r < s.length()) {
        // c是即将进入窗口的字符
        char c = s[r];
        window.add(cur);
        r++; // 增大窗口
        // 进行窗口内数据的更新
        ...
            
        // 判断左侧窗口是否要收缩
        while (l < r && need2Shrink()) {
            // 将字符 d 移出窗口
            char d = s[l];
            window.remove(d);
            l++; // 缩小窗口
            // 窗口之内数据的更新
            ...
            
        }
    }
    
}
```

<u>**上面的框架中， `...`表示更新窗口数据地方，在具体的题目中，需要填写代码逻辑。**</u>

**① 二分搜索**

**② 滑动窗口**

**③ 前缀和**

**④ 差分数组**

## 2.4 二叉树算法

二叉树的递归解法可以分为两类思路，第一类是**遍历**一遍二叉树得出答案，第二类可以通过**分解问题**计算出答案。

### 2.4.1 遍历思维模式

例如二叉树的前|中|后序遍历等。

### 2.4.2 分解问题的思维模式

计算二叉树最大深度的问题，可以使用如下的解法：

```java
int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 递归结算左右子树的最大深度
    int leftMax = maxDepth(root.left);
    int rightMax = maxDepth(root.right);
    // 整棵树的最大深度就是左右子树的最大深度 + 1 （根节点）
    int res = Math.max(leftMax, rightMax) + 1;
    return res;
}
```

# 5 习题汇总

## 5.1 双指针

### 5.1.1 双指针解决链表

> 当我们需要创建一条新的单向链表的时候，可以使用虚拟头结点来简化边界处理的情况。

本节所有的源码地址为：[点击跳转](https://github.com/shepi-666/algorithm/tree/master/src/online/labuladong/algo/doublepointer/linkedlist)

#### T21 合并两个有序链表

**题目表述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**我的思路**

* 虚拟头结点，两个指针分别指向两个链表
* 循环指向两个链表
* 最后处理一下边界条件

#### T86 分隔链表

**题目描述**

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**我的思路**

* 创建两个子链表，分别用来存储小于等于和大于的节点
* 使用双指针，将原链表中的节点拆分到两个子链表
* 两个链表合并起来，返回

> 一定注意链表的指针问题，修改原链表的时候，要使用临时指针存储。
>
> 构建新链表的时候，只需要当前节点的值，所以我们一定要将当前节点和原链表断开连接，防止对新链表造成影响

#### T23 合并K个升序链表

**题目描述**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**我的思路**

* 将所有的链表放到优先队中
* 取出最小的，构建新链表
* 将下一个节点放到优先队列，重构大顶堆

**复杂度分析**

* 时间复杂度

  队列元素一共为`k`个，每次`add`或者`poll`复杂度为$o(logK)$，总共有`N`个节点，那么时间复杂度有$o(NlogK)$

* 空间复杂度

  优先队列：元素为$k$个，所以空间复杂度为$k$

#### T19 删除链表的倒数第N个节点

**题目描述**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**我的思路**

* 快慢两个指针，快指针`fast`先走`n`步
* 快慢指针一起走，直到快指针走到`tail`
* 此时慢指针的位置在倒数第$N-1$个元素
* 删除慢指针的`next`元素

> 链表最后一个非`null`节点的条件：`p.next != null`
>
> 这一题同样需要使用虚拟头结点

#### T876 链表的中间节点

**题目描述**

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**我的思路**

* 使用快慢指针，快指针`fast`一次走两步，慢指针`slow`一次走一步
* 循环条件为`fast != null && fast.next != null `
* 跳出循环之后，需要检查`fast`的值
  * 如果`fast != null` 说明当前是偶数节点，需要返回`slow.next`
  * 如果`fast == null`说明当前是奇数节点，需要返回`slow`
* 同样需要使用虚拟头结点

#### T141 环形链表

**题目描述**

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

**我的思路**

* 使用快慢指针
* 快指针循环条件为`fast != null && fast.next != null`
  * 如果跳出循环条件：无环
  * 如果快慢指针相遇：则有环

#### T142 环形链表II

**题目描述**

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**我的思路**

* 使用快慢指针

* 快指针循环条件为`fast != null && fast.next != null`

* 如果两个指针相遇：

  * 快指针走到的路程：$2k$

  * 慢指针的路程：$k$

  * 假设`head->node`头结点到环节点的路程为$L$，环节点到相遇节点的距离为$x$，相遇节点到尾结点的距离为$y$，则
    $$
    \left\{
    \begin{array}{rl}
    L + 2x + y &= 2k,\\
    L + x &= k\\
    \end{array} \right.
    $$

  根据公式可以推导出$L = y$。

* 两个指针相遇的时候，快指针指向头结点，速度降为1，走$L$路程之后，二者相遇，此时记为**环节点**

> 两个指针相遇之后，快指针往后走一步`fast = head;`，慢指针一定也要往后走一步`slow = slow.next;`

#### T160 相交链表

**题目描述**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表**相交的起始节点**。如果两个链表不存在相交节点，返回 `null` 

**我的思路**

* 链表`list1`的长度为$L_1 + L_0$，链表`list2`的长度为$L_2 + L_0$，其中$L_0$为公共部分的长度
* `p1`指针遍历完`list1`之后，开始遍历`list2`
* `p2`指针遍历`list2`之后，开始遍历`list1`
* 相遇时两个指针走的距离为$L_0 + L_1 + L_2$
* 返回相遇时候的节点

> 由于不确定两个链表是否相交，最好遍历之后找到两个链表的长度和即`lenA + lenB`
>
> 遍历`lenA + lenB`个节点，如果相同节点，就直接跳出，否则循环结束返回`null`
>
> 记住，遍历到末尾的时候，如果`p1.next == null`，不能将`p1.next = headB`的方式指定下一跳，这样会修改链表的结构，正确的做法为:`p1 = p1.next == null ? headB : p1.next`

#### T83 删除有序链表中重复的节点

**题目描述**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**我的思路**

* 快慢指针，慢指针指向有效元素，快指针遍历链表
* 如果元素相同，快指针网前走一步，慢指针指向快指针
* 如果元素不同，因为上一步中，慢指针的下个节点已经连接到快指针了，所以慢指针需要往前走一步，指向新的不同的节点，快指针走一步
* 循环结束条件：`fast == null`



### 5.1.2 双指针解决数组

#### T26 删除有序数组中的重复项

**题目描述**

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

**我的思路**

* 快慢指针，快指针去检测发生跳变的点，慢指针标记有效数组的索引
* 如果发生跳变，`nums[++slow] = nums[fast]`
* 循环结束条件`fast = nums.length`
* 返回值为数组的有效长度，即`++slow`

#### T27 移除元素

**题目描述**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**我的思路**

* 快慢双指针，慢指针指向有效索引位置，快指针遍历寻找不同于`val`的元素
* 如果`fast == val`相同，快指针直接跳过
* 如果`fast != null`不同，慢指针所在索引添加元素`nums[slow++] = nums[fast++]`，双指针各向前移动一步
* 注意慢指针的索引是个左闭右开的区间，即有效元素索引为$[0, slow)$
* 返回有效长度为`slow`

#### T283 移动零

**题目描述**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**我的思路**

* 和上一题换汤不换药，快慢双指针，快指针遍历元素，寻找非零元素，慢指针指数组有效位置末尾
* 同样需要注意的是慢指针是个左闭右开的区间，即有效元素索引为$[0, slow)$
* 最后需要将闭区间$[slow, nums.length - 1]$的元素置为$0$

#### T76 最小覆盖字串

**题目描述**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**我的思路**

* 使用两个`Map`来存储字符的词频，即`tDict`和`winDict`
* **涵盖**：需要有一个方法来判断是否是涵盖关系，即`isCovering(winStr, t)`
* 如果涵盖的话，左指针进行剪枝，缩减窗口，直到不涵盖
* 如果不涵盖，右指针前进，直到涵盖
* 找到结果了，就将结果存储在`minWin`中

#### T567 字符串的排列

**题目描述**

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的 排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

**我的思路**

和上一题基本相同，都是**涵盖**的问题。

* 创建一个数组`int[26]`记录子串的频次表，一个数组`win[26]`表示当前窗口的频次表
* 如果不涵盖，窗口右扩，添加新字符

> 注意，此题中窗口的长度固定为`s1.length`

#### T438 找到字符串中所有字母异位词

**题目描述**

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**我的思路**

* 滑动窗口，窗口固定
* 两个字典记录字符频次`int[26] tar`和`int[26] win`
* 初始化两个字典之后需要判断是否**涵盖**
* 窗口左边界`l`即为起始索引

> 需要单独判断最后一个窗口，它会因为右开区间跳出循环而少一次判断

#### T3 无重复字符串的最长字串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**我的思路**

* 记录窗口字符频次的字典`int[128] winDict`
* 是否**重复**：判断`winDict`中某个字符的频次大于`2`
* 如果未出现重复：窗口往右扩，添加新字符
* 如果出现重复：
  * 记录此时窗口的大小，更新最从长字符串
  * 窗口左边缩小，左边界移除`s.charAt(r)`
* 返回最长字符串的长度

> 需要单独判断最后一个窗口，他会因为右开区间跳出循环而少一次判断

