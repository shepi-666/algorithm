# 1 总览

> 关于数据结构和算法的**精炼总结**：
>
> * 所有的数据结构，底层皆为**数组**（顺序存储）和**链表**（链式存储）
> * 数据结构的关键点在于**遍历和访问**，即元素的增删改查等基本操作
> * 所有的算法，本质皆为**穷举**
> * 穷举的关键点在于**无遗漏和无冗余**。熟悉掌握算法框架，可以做到无遗漏；充分利用信息，可以做到无冗余。

## 1.1 数据结构的存储方式

如上文所讲，数据结构的存储方式只有两种：**数组**和**链表**

## 1.2 数据结构的基本操作

对于任何数据结构，其基本操作为**遍历和访问**，具体来讲就是增删改查

* **线性结构**：使用`for|while`循环
* **非线性结构**：使用**递归**遍历

# 2 算法的本质

算法的本质是**穷举**。

穷举的两个关键：

* **无遗漏**：出现遗漏是对算法框架的掌握不到位，不能正确穷举代码
* **无冗余**：没有充分利用有效信息

面对一道算法题，两个维度思考：

* **如何穷举？**无遗漏穷举出所有的可能解
* **如何聪明地穷举**？避免所有的冗余计算，尽可能少地消耗资源求出答案

## 2.1 如何穷举？

**递归类问题**、**回溯算法**、**动态规划算法**等算法的解题关键在于如何正确地穷举。

* **回溯算法**的核心在于**遍历**
* **动态规划**核心在于**分解问题**

## 2.2 如何聪明地穷举？

**二分搜索算法**、**并查集**、**贪心算法**

# 3 数组|链表系列算法

## 3.1 单链表

单链表常用的解题技巧为**双指针**，属于**聪明穷举**一类。

常见的链表题目有：[双指针解决链表](#5.1.1 双指针解决链表)

## 3.2 数组

常用的解题技巧为**双指针**，属于**聪明穷举**一类。

双指针的技巧主要分为两类：**左右指针**和**快慢指针**。

* **左右指针**：两个指针相向而行或者相背而行
* **快慢指针**：两个指针同向而行，但是一快一慢

### 3.2.1 快慢指针技巧

##### 1） 原地修改

[T26删除有序数组的重复项](#T26 删除有序数组中的重复项)、[T27 移除元素](#T27 移除元素)、[T283 移动零](#T283 移动零)

##### 2）滑动窗口

滑动窗口主要用来解决**子数组的问题**，比如寻找某个条件的最长或者最短的子数组。

滑动窗口本质上就是维护一个可变大小的窗口，不断滑动，更新答案，算法的逻辑如下：

```java
int left = 0, right = 0;

while (right < nums.length) {
    // 增大窗口
    window.addLast(nums[right]);
    right++;
    
    // 缩小窗口
    while (windows needs shrink) {
        window.removeFirst(nums[left]);
        left++;
    }
}
```

基于滑动窗口的算法的时间复杂度为$o(N)$ ，左右双指针不会回退，只会增加，每个元素最多完成一次入窗或者出窗的操作。

> 注意：滑动窗 并不能穷举出所有的子串，滑动窗是利用已有条件，帮助我们聪明地穷举，进行剪枝优化，避免冗余计算。

==*重要*== 以下是一套滑动窗口的代码框架，适用性非常强，只需要按照要求在相关的地方修改即可。

```java
void slidingWindow(String s) {
    /* 使用合适的数据结构记录窗口中的数据，根据场景变通
     * 例如记录元素出现的频次，就用 map
     * 例如记录窗口中出现的元素和，可以使用 int
     */
    Object window = new Object;
    
    int l = 0, right = 0; // 窗口的边界
    while (r < s.length()) {
        // c是即将进入窗口的字符
        char c = s[r];
        window.add(cur);
        r++; // 增大窗口
        // 进行窗口内数据的更新
        ...
            
        // 判断左侧窗口是否要收缩
        while (l < r && need2Shrink()) {
            // 将字符 d 移出窗口
            char d = s[l];
            window.remove(d);
            l++; // 缩小窗口
            // 窗口之内数据的更新
            ...
            
        }
    }
    
}
```

<u>**上面的框架中， `...`表示更新窗口数据地方，在具体的题目中，需要填写代码逻辑。**</u>

### 3.2.2 左右指针心法

#####  1）二分搜索

二分搜索并不是一个简单的算法，要非常注意**细节问题**，

最令人头痛的问题：

* 就是`mid + 1`还是`mid - 1`，
* `while`里头 到底用的是`<=`还是`<`严格小于

<u>二分查找的基本框架为</u>：

```java
int binaraySearch(int[] nums, int target) {
    int left = 0, right = ...;
    
    while(condition) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            // TODO
        } else if (nums[mid] < target) {
            left = ...;
        } else if (nums[mid] > target) {
            right = ...;
        }
    }
}
```

**分析二分查找法的技巧就是：将所有的 `if`条件书写明白，不要出现含义不明的`else`，这样有注意把握细节。**

> 为了防止`mid`溢出，采用`left + (right - left) / 2` 而不是 `(left + right) / 2`

**1）寻找一个数**

二分法最常用的一个场景。例如[T704 二分查找](#T704 二分查找)。

在此讨论一下二分法的实现细节：

**为什么是`while (l <= r)`？**

初始化`r`的值为`nums.length - 1`而不是`nums.length`，算法的**搜索区间**为`[l, r]`是一个**左闭右闭**的区间。

对于`<=`算法的终止条件为`l = r + 1`,搜索区间为`[r+1, r]`里面不含有有效元素，而对于`<`，算法的终止条件为`l = r`即`[r, r]`，搜索区间依旧有一个有效元素为`r`，会遗漏掉此元素。

**此算法有什么缺陷**？

如果有多个目标值，例如`nums = [1, 2, 2, 2, 3]`，`target = 2`，返回结果为`index = 2`，无法得出左侧边界`1`和右侧边界索引`3`。

**2）寻找左侧边界的二分法**

```java
int leftBound(int[] nums, int target) {
    int l = 0;
    int r = nums.length; // :note1
    
    while (l < r) { // :note2
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            r = mid;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            r = mid; // :note3
        }
    }
    return left; // note4
}
```

**note2** 为什么循环终止条件为`<`？

这是因为初始化右边界为`nums.length`，搜索区间是一个左闭右开的区间即：$[l, r)$，所以`l == r`即可保证正确终止。

**note4**：当`target`不存在的时候，返回的值是什么？

当`target`不存在的时候，返回的是**大于**`target`**值的最小值的索引**。

**note3**：为什么是`r == mid`？

还是和算法的搜索区间有关，搜索区间是个开区间，为了不漏检掉`mid - 1`，右侧开区间只能为`r = mid`

**为什么算法能够搜索左侧边界**？

关键在于`nums[mid] == target`,关键是锁定上界`right`，在区间`[l, mid)`中继续搜索，不断向左收缩，锁定左边界。

**3）寻找右侧边界的二分查找**

```java
int rightBound(int[] nums, int target) {
    int l = 0; int r = nums.length;
    
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            l = mid + 1;
        } else if (nums[mid] < target) {
            l = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return right - 1;
}
```

> 当`target`不存在的时候，返回的是小于`target`最大值的索引。

**总之，最主要的就是确定算法的搜索区间是开区间还是闭区间，一定不能遗漏搜索任何一个元素。**

##### 2）n数之和

[T167 两数之和II-输入为有序数组](#T167 两数之和II-输入为有序数组)

> 左右指针动态调整**和**的大小，框架代码有一点像二分法。

##### 3）反转数组

[T344 反转字符串](#T344 反转字符串)

##### 4）回文串判断

所谓回文串，就是从左往右读和从右往左读都是相同的，例如`aba`等。



**③ 前缀和**

**④ 差分数组**

#  4 二叉树算法

二叉树的递归解法可以分为两类思路，第一类是**遍历**一遍二叉树得出答案，第二类可以通过**分解问题**计算出答案。

## 4.1 遍历思维模式

例如二叉树的前|中|后序遍历等。

##  4.2 分解问题的思维模式

计算二叉树最大深度的问题，可以使用如下的解法：

```java
int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 递归结算左右子树的最大深度
    int leftMax = maxDepth(root.left);
    int rightMax = maxDepth(root.right);
    // 整棵树的最大深度就是左右子树的最大深度 + 1 （根节点）
    int res = Math.max(leftMax, rightMax) + 1;
    return res;
}
```

