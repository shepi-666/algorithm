# 1 双指针解决链表

> 当我们需要创建一条新的单向链表的时候，可以使用虚拟头结点来简化边界处理的情况。

本节所有的源码地址为：[点击跳转](https://github.com/shepi-666/algorithm/tree/master/src/online/labuladong/algo/doublepointer/linkedlist)

## T21 合并两个有序链表

**题目表述**

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**我的思路**

* 虚拟头结点，两个指针分别指向两个链表
* 循环指向两个链表
* 最后处理一下边界条件

## T86 分隔链表

**题目描述**

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。

**我的思路**

* 创建两个子链表，分别用来存储小于等于和大于的节点
* 使用双指针，将原链表中的节点拆分到两个子链表
* 两个链表合并起来，返回

> 一定注意链表的指针问题，修改原链表的时候，要使用临时指针存储。
>
> 构建新链表的时候，只需要当前节点的值，所以我们一定要将当前节点和原链表断开连接，防止对新链表造成影响

## T23 合并K个升序链表

**题目描述**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**我的思路**

* 将所有的链表放到优先队中
* 取出最小的，构建新链表
* 将下一个节点放到优先队列，重构大顶堆

**复杂度分析**

* 时间复杂度

  队列元素一共为`k`个，每次`add`或者`poll`复杂度为$o(logK)$，总共有`N`个节点，那么时间复杂度有$o(NlogK)$

* 空间复杂度

  优先队列：元素为$k$个，所以空间复杂度为$k$

## T19 删除链表的倒数第N个节点

**题目描述**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**我的思路**

* 快慢两个指针，快指针`fast`先走`n`步
* 快慢指针一起走，直到快指针走到`tail`
* 此时慢指针的位置在倒数第$N-1$个元素
* 删除慢指针的`next`元素

> 链表最后一个非`null`节点的条件：`p.next != null`
>
> 这一题同样需要使用虚拟头结点

## T876 链表的中间节点

**题目描述**

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**我的思路**

* 使用快慢指针，快指针`fast`一次走两步，慢指针`slow`一次走一步
* 循环条件为`fast != null && fast.next != null `
* 跳出循环之后，需要检查`fast`的值
  * 如果`fast != null` 说明当前是偶数节点，需要返回`slow.next`
  * 如果`fast == null`说明当前是奇数节点，需要返回`slow`
* 同样需要使用虚拟头结点

## T141 环形链表

**题目描述**

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

**我的思路**

* 使用快慢指针
* 快指针循环条件为`fast != null && fast.next != null`
  * 如果跳出循环条件：无环
  * 如果快慢指针相遇：则有环

## T142 环形链表II

**题目描述**

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**我的思路**

* 使用快慢指针

* 快指针循环条件为`fast != null && fast.next != null`

* 如果两个指针相遇：

  * 快指针走到的路程：$2k$

  * 慢指针的路程：$k$

  * 假设`head->node`头结点到环节点的路程为$L$，环节点到相遇节点的距离为$x$，相遇节点到尾结点的距离为$y$，则
    $$
    \left\{
    \begin{array}{rl}
    L + 2x + y &= 2k,\\
    L + x &= k\\
    \end{array} \right.
    $$

  根据公式可以推导出$L = y$。

* 两个指针相遇的时候，快指针指向头结点，速度降为1，走$L$路程之后，二者相遇，此时记为**环节点**

> 两个指针相遇之后，快指针往后走一步`fast = head;`，慢指针一定也要往后走一步`slow = slow.next;`

## T160 相交链表

**题目描述**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表**相交的起始节点**。如果两个链表不存在相交节点，返回 `null` 

**我的思路**

* 链表`list1`的长度为$L_1 + L_0$，链表`list2`的长度为$L_2 + L_0$，其中$L_0$为公共部分的长度
* `p1`指针遍历完`list1`之后，开始遍历`list2`
* `p2`指针遍历`list2`之后，开始遍历`list1`
* 相遇时两个指针走的距离为$L_0 + L_1 + L_2$
* 返回相遇时候的节点

> 由于不确定两个链表是否相交，最好遍历之后找到两个链表的长度和即`lenA + lenB`
>
> 遍历`lenA + lenB`个节点，如果相同节点，就直接跳出，否则循环结束返回`null`
>
> 记住，遍历到末尾的时候，如果`p1.next == null`，不能将`p1.next = headB`的方式指定下一跳，这样会修改链表的结构，正确的做法为:`p1 = p1.next == null ? headB : p1.next`

## T83 删除有序链表中重复的节点

**题目描述**

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**我的思路**

* 快慢指针，慢指针指向有效元素，快指针遍历链表
* 如果元素相同，快指针网前走一步，慢指针指向快指针
* 如果元素不同，因为上一步中，慢指针的下个节点已经连接到快指针了，所以慢指针需要往前走一步，指向新的不同的节点，快指针走一步
* 循环结束条件：`fast == null`



# 2 双指针解决数组

## T26 删除有序数组中的重复项

**题目描述**

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

**我的思路**

* 快慢指针，快指针去检测发生跳变的点，慢指针标记有效数组的索引
* 如果发生跳变，`nums[++slow] = nums[fast]`
* 循环结束条件`fast = nums.length`
* 返回值为数组的有效长度，即`++slow`

## T27 移除元素

**题目描述**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**我的思路**

* 快慢双指针，慢指针指向有效索引位置，快指针遍历寻找不同于`val`的元素
* 如果`fast == val`相同，快指针直接跳过
* 如果`fast != null`不同，慢指针所在索引添加元素`nums[slow++] = nums[fast++]`，双指针各向前移动一步
* 注意慢指针的索引是个左闭右开的区间，即有效元素索引为$[0, slow)$
* 返回有效长度为`slow`

## T283 移动零

**题目描述**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**我的思路**

* 和上一题换汤不换药，快慢双指针，快指针遍历元素，寻找非零元素，慢指针指数组有效位置末尾
* 同样需要注意的是慢指针是个左闭右开的区间，即有效元素索引为$[0, slow)$
* 最后需要将闭区间$[slow, nums.length - 1]$的元素置为$0$

## T76 最小覆盖字串

**题目描述**

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**我的思路**

* 使用两个`Map`来存储字符的词频，即`tDict`和`winDict`
* **涵盖**：需要有一个方法来判断是否是涵盖关系，即`isCovering(winStr, t)`
* 如果涵盖的话，左指针进行剪枝，缩减窗口，直到不涵盖
* 如果不涵盖，右指针前进，直到涵盖
* 找到结果了，就将结果存储在`minWin`中

## T567 字符串的排列

**题目描述**

给你两个字符串 `s1` 和 `s2` ，写一个函数来判断 `s2` 是否包含 `s1` 的 排列。如果是，返回 `true` ；否则，返回 `false` 。

换句话说，`s1` 的排列之一是 `s2` 的 **子串** 。

**我的思路**

和上一题基本相同，都是**涵盖**的问题。

* 创建一个数组`int[26]`记录子串的频次表，一个数组`win[26]`表示当前窗口的频次表
* 如果不涵盖，窗口右扩，添加新字符

> 注意，此题中窗口的长度固定为`s1.length`

## T438 找到字符串中所有字母异位词

**题目描述**

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**我的思路**

* 滑动窗口，窗口固定
* 两个字典记录字符频次`int[26] tar`和`int[26] win`
* 初始化两个字典之后需要判断是否**涵盖**
* 窗口左边界`l`即为起始索引

> 需要单独判断最后一个窗口，它会因为右开区间跳出循环而少一次判断

## T3 无重复字符串的最长字串

**题目描述**

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**我的思路**

* 记录窗口字符频次的字典`int[128] winDict`
* 是否**重复**：判断`winDict`中某个字符的频次大于`2`
* 如果未出现重复：窗口往右扩，添加新字符
* 如果出现重复：
  * 记录此时窗口的大小，更新最从长字符串
  * 窗口左边缩小，左边界移除`s.charAt(r)`
* 返回最长字符串的长度

> 需要单独判断最后一个窗口，他会因为右开区间跳出循环而少一次判断

## T704 二分查找

**题目描述**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**我的思路**

* 左右指针实现二分查找
* 左指针初始化为`l = 0`，右指针初始化为`r = nums.length - 1`
* 循环结束条件为`while (l <= r)`

## T34 在排序数组中查找元素第一和最后一个位置

**题目描述**

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**我的思路**

* 使用二分法查找左边界，然后从左边界线性寻找右边界
* 左右指针初始化`int l = 0, r = nums.length`
* 循环结束条件`l < r`
* 判断`l`是否越界，即 `l > nums.length - 1 || nums[l] == target`
* 从`l`线性寻找`r`的位置

## T167 两数之和II-输入为有序数组

**题目描述**

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**我的思路**

* 左右双指针，往中间收缩
* 初始化为`int l = 0, r = nums.length - 1`
* 如果和大于目标，右指针移动
* 如果和小于目标，左指针移动
* 循环条件为`l < r`
* 结果要加1，表示第`n`个索引

## T344 反转字符串

**题目描述**

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

**我的思路**

* 左右双指针，临时变量进行交换。
* 循环条件为`while (l < r)`

## T5 最长回文子串

**题目描述**

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**我的思路**

* 判断回文串的方法`isPalindrome(l, r, s)`
* 递归判断：**[超时]**
  * 判断当前串是否是回文串`isPalindrome(l, r, s)`，是的话直接返回
  * 左缩1位，判断是否是回文串`isPalindrome(l+1, r, s)`
  * 左缩1位，判断是否是回文串`isPalindrome(l, r-1, s)`

**思路2**

* 判断区间为$[0, s.length()-2]$
* 对区间每个字符向两边扩散，双指针向北而行
* 分别计算出奇数扩散和偶数扩散的回文串，取最长更新`resStr`
* 扩散边界条件为`l > 0, r < s.length() - 1`

